import java.io.IOException;
import java.util.*;

/**
 * Created by Jiati Le on 2/23/16.
 * Andrew ID: jiati
 * l
 */
public class QryIopWindow extends QryIop {

    private int distance;

    public QryIopWindow (String input_disatnce) {
        this.distance = Integer.parseInt(input_disatnce);
    }

    public QryIopWindow (int input_distance) {
        this.distance = input_distance;
    }
    @Override
    protected void evaluate () throws IOException {

        // Creat an empty inverted list to store result.
        this.invertedList = new InvList(this.getField());

//        for near operator, there must be at least two arugments.
        if (args.size() < 2 ) {
            throw new IllegalArgumentException("Window must have two or more " +
                    "arguments!");
        }

//        each document a time.
        while (true) {

            int passDocid = Qry.INVALID_DOCID;
//            put each arg's match docid in a list
            List<Integer> docidList = new ArrayList<>();
            for (Qry q: this.args) {
                if (q.docIteratorHasMatch(null)) {
                    int qDocid = q.docIteratorGetMatch();
                    docidList.add(qDocid);
                } else {
                    return;
                }
            }
            boolean equal = false;
//            this loop will compare whether each integer in docidlist is
// equal to other.
            while (!equal) {
                int diff = docidList.get(0);
                int count = 0;
                for (int j: docidList) {
                    if (j != diff) {
                        count++;
                    }
                }
                if (count == 0) {
                    passDocid = docidList.get(0);
                    equal = true;
                    break;
                }
                // if docid don't match all. extract the smallest docid and
                // move its dociterator to next doc. this loop will go on
                // until we get a matched document or we process all the
                // documents.
                int minInd = docidList.indexOf(Collections.min(docidList));
                Qry q_e = this.args.get(minInd);
                if (!q_e.docIteratorHasMatch(null)) {
                    break;
                } else {
                    int minDocid = q_e.docIteratorGetMatch();
                    q_e.docIteratorAdvancePast(minDocid);
                    if (q_e.docIteratorHasMatch(null)) {
                        int nextDocid = q_e.docIteratorGetMatch();
                        docidList.set(minInd, nextDocid);
                    } else {
                        return;
                    }
                }
            }

//            this should be at the end of this while.
//            we should get a matched docid, otherwise there are no more
//            document to process.
            if (!equal && passDocid == INVALID_DOCID) {
                return;
            }

//            finalPosition is a Vector to store locations, we use greedy
//            algorithm.

            Vector<Integer> finalPosition = new Vector<>();
//            this is the list contain location of each query.
            List<Integer> locList = new ArrayList<>();
            for (int i = 0; i < this.args.size(); i++) {
                Qry q =this.args.get(i);
                locList.add(((QryIop) q).locIteratorGetMatch());
            }
            boolean locHasMatch = true;
            while (locHasMatch) {
                int maxLoc = Collections.max(locList);
                int minLoc = Collections.min(locList);
//                if this window meet requirement
                if (maxLoc - minLoc < distance) {
                    finalPosition.add(finalPosition.size(), maxLoc);
                    loop:
//                    update every location in location list to find next match
                    for (int i = 0; i < this.args.size(); i++) {
                        Qry q =  this.args.get(i);
                        ((QryIop) q).locIteratorAdvance();
                        if (((QryIop) q).locIteratorHasMatch() == false) {
                            locHasMatch = false;
                            break loop;
                        }
                        int location = ((QryIop) q).locIteratorGetMatch();
                        locList.set(i, location);
                    }
                } else {
//                    if we can't update the minimum location to find next match
                    int indMin = locList.indexOf(Collections.min(locList));
                    Qry q = this.args.get(indMin);
                    ((QryIop) q).locIteratorAdvance();
                    if (((QryIop) q).locIteratorHasMatch()) {
                        locList.set(indMin, ((QryIop) q).locIteratorGetMatch());
                    } else {
                        locHasMatch = false;
                    }
                }
            }

            if (! finalPosition.isEmpty()) {
                this.invertedList.appendPosting(passDocid, finalPosition);
            }
//            now in docidList each elements is equal. move one of them to
//            find next matched document.
            int minInd = docidList.indexOf(Collections.min(docidList));
            Qry q_e = this.args.get(minInd);
            if (!q_e.docIteratorHasMatch(null)) {
                break;
            } else {
                int minDocid = q_e.docIteratorGetMatch();
                q_e.docIteratorAdvancePast(minDocid);
                if (q_e.docIteratorHasMatch(null)) {
                    int nextDocid = q_e.docIteratorGetMatch();
                    docidList.set(minInd, nextDocid);
                } else {
                    return;
                }
            }
        }
    }

    @Override
    public String toString() {
        String result = new String();
        for (int i = 0; i < this.args.size(); i++) {
            result = result + this.args.get(i);
        }
        result = this.getDisplayName() + "/" + Integer.toString(this
                .distance) + "(" + result + ")";
        return result;
    }
}
